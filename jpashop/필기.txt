
------------------- 07.19 @Entity 어노테이션  ------------------------------

@Entity 어노테이션은 JPA(Java Persistence API)에서 엔티티 클래스를 나타내는 데 사용되는 어노테이션입니다.
엔티티 클래스는 데이터베이스와 매핑되는 객체를 의미하며, JPA를 사용하여 데이터베이스와 상호작용하는데 필요한 정보를 제공합니다.
@Entity 어노테이션을 클래스에 붙이면 해당 클래스가 JPA 엔티티임을 나타냅니다.
JPA는 @Entity 어노테이션이 붙은 클래스를 데이터베이스의 테이블과 매핑하여 객체를 영구 저장소에 저장하고 관리합니다.
@Entity 어노테이션의 주요 특징은 다음과 같습니다:

JPA에서 관리하는 엔티티 클래스는 반드시 @Entity 어노테이션이 붙어야 합니다.
@Entity 어노테이션이 붙은 클래스는 JPA의 영속성 컨텍스트에서 관리되며, 데이터베이스와 매핑되는 역할을 수행합니다.
@Entity 어노테이션을 사용하는 클래스는 기본 생성자가 반드시 필요하며, 파라미터가 없는 기본 생성자를 갖고 있어야 합니다.
@Entity 어노테이션을 사용하여 JPA 엔티티 클래스를 정의하면, JPA는 해당 클래스와 연결된 데이터베이스 테이블을 자동으로 생성하고,
엔티티의 상태를 추적하고, 영속성 컨텍스트를 통해 엔티티를 관리하는 등의 기능을 제공합니다.


------------------- 07.19 @Embeddable & @Embedded ------------------------------

@Embeddable과 @Embedded는 스프링 부트에서 JPA를 사용할 때 엔티티 클래스의 속성을 재사용하거나 복합적인 값으로 표현하기 위해 사용되는 어노테이션입니다.

@Embeddable : @Embeddable 어노테이션은 복합적인 값(Composite Value)을 표현하기 위해 사용되는 클래스에 지정됩니다. 즉, 해당 클래스가 다른 엔티티에 속성으로 포함되어 사용될 수 있음을 나타냅니다.
예를 들어, 주소 정보를 여러 엔티티에서 공통으로 사용해야 할 경우 @Embeddable 어노테이션을 사용하여 Address 클래스를 정의하고, 해당 엔티티들의 속성으로 Address 클래스를 사용할 수 있습니다.

@Embeddable
public class Address {
    private String city;
    private String street;
    private String zipCode;

    // getters, setters, constructors, etc.
}

@Embedded : @Embedded 어노테이션은 @Embeddable 어노테이션이 지정된 클래스를 해당 엔티티의 속성으로 포함시킬 때 사용됩니다.
엔티티 클래스의 속성으로 @Embedded 어노테이션을 사용하여 @Embeddable 어노테이션이 지정된 클래스를 포함시킵니다.

@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @Embedded
    private Address address;

    // getters, setters, constructors, etc.
}
위의 예시에서 Customer 엔티티는 Address 클래스를 속성으로 포함하고 있으며, 이렇게 함으로써 Customer 엔티티의 데이터베이스 테이블에 city, street, zipCode 속성들이
컬럼으로 포함됩니다. 이러한 방식으로 코드의 재사용성을 높이고, 복합적인 값들을 관리하기 쉽게 할 수 있습니다.


-------------------- 07.19 Entity 클래스들간의 관계를 나타낼 때 사용되는 어노테이션 -----------------------------------

@OneToOne: 일대일(One-to-One) 관계를 표현할 때 사용됩니다. 두 개의 엔티티 클래스가 서로 하나의 관계를 맺는 경우에 사용합니다.
@OneToMany: 일대다(One-to-Many) 관계를 표현할 때 사용됩니다. 하나의 엔티티가 다수의 다른 엔티티와 관계를 맺는 경우에 사용합니다.
@ManyToOne: 다대일(Many-to-One) 관계를 표현할 때 사용됩니다. 다수의 엔티티가 하나의 다른 엔티티와 관계를 맺는 경우에 사용합니다.
@ManyToMany: 다대다(Many-to-Many) 관계를 표현할 때 사용됩니다. 여러 엔티티가 여러 다른 엔티티들과 서로 다대다 관계를 맺을 때 사용합니다.

mappedBy는 JPA에서 양방향(두 엔티티 간에 서로 참조하는) 관계를 매핑할 때 사용되는 속성입니다. mappedBy는 일반적으로 @OneToMany와 @OneToOne 어노테이션에서 사용됩니다.
양방향 관계를 설정할 때, 일반적으로 한 쪽의 엔티티(주인 엔티티)가 다른 쪽의 엔티티(역방향 엔티티)를 참조하도록 매핑을 지정합니다.
이 때 mappedBy를 사용하여 역방향 엔티티가 어떤 필드를 통해 주인 엔티티와 매핑되었는지를 지정합니다.

예를 들어, 다음과 같이 Post 엔티티와 Comment 엔티티가 있을 때, Post 엔티티가 Comment 엔티티를 일대다 관계로 참조하고 있습니다.

java
Copy code
@Entity
public class Post {
    @Id
    @GeneratedValue
    private Long id;

    private String title;

    @OneToMany(mappedBy = "post")
    private List<Comment> comments;

    // Getters, setters, constructors, etc.
}

@Entity
public class Comment {
    @Id
    @GeneratedValue
    private Long id;

    private String text;

    @ManyToOne
    private Post post;

    // Getters, setters, constructors, etc.
}
위의 예시에서 Post 엔티티에서 comments 필드에 @OneToMany(mappedBy = "post") 어노테이션을 사용했습니다.
이렇게 함으로써 Comment 엔티티의 post 필드가 Post 엔티티의 comments 필드를 참조하도록 매핑되었다고 지정합니다. 따라서 양방향으로 관계를 설정할 수 있습니다.

mappedBy는 엔티티 관계에서 중요한 개념이며, 엔티티 간의 관계를 정확하게 설정하기 위해 잘 이해하고 사용하는 것이 중요합니다.

이러한 어노테이션들을 사용하여 엔티티 클래스들 간의 관계를 설정하고, 데이터베이스에서 이를 올바르게 매핑할 수 있습니다.


-------------------- 07.19 Entity간의 연관관계를 가져오는 방식 -----------------------------------

연관 관계의 즉시로딩(Eager Loading)과 지연로딩(Lazy Loading)은 JPA에서 엔티티 간의 관계를 가져오는 방식을 나타내는 개념입니다.

즉시로딩 (Eager Loading):
즉시로딩은 엔티티를 조회할 때, 해당 엔티티와 연관된 다른 엔티티들을 모두 한 번에 가져오는 방식입니다. 예를 들어, 엔티티 A와 B가 일대다(One-to-Many) 관계를 가지고 있을 때, 
A를 조회할 때 연관된 모든 B 엔티티들도 함께 조회하는 방식이 즉시로딩입니다. 이렇게하면 한 번의 쿼리로 모든 연관 엔티티를 가져올 수 있지만, 데이터베이스의 부담이 커질 수 있습니다.
즉시로딩의 장점은 조회한 엔티티와 연관된 데이터들을 사용할 때 데이터베이스 조회가 필요없이 바로 접근할 수 있어서 성능이 좋을 수 있습니다. 그러나 연관된 데이터가 많고 복잡할 경우에는 성능 이슈가 발생할 수 있으므로 신중하게 사용해야 합니다.

지연로딩 (Lazy Loading):
지연로딩은 연관된 엔티티를 실제로 사용하는 시점까지 데이터베이스에서 가져오지 않고, 해당 엔티티가 실제로 필요할 때 가져오는 방식입니다. 즉, 해당 연관 엔티티를 사용하는 순간에 데이터베이스에서 조회하여 가져오게 됩니다. 
지연로딩은 실제로 해당 데이터가 사용되지 않는 경우에는 데이터베이스 조회를 하지 않으므로, 성능상의 이점이 있습니다.
지연로딩의 장점은 원하는 시점에 실제로 필요한 데이터만 가져오기 때문에 데이터베이스 부하를 줄일 수 있습니다. 그러나 지연로딩된 엔티티를 사용하는 시점에 영속성 컨텍스트의 범위를 벗어난 경우에는 LazyInitializationException 예외가 발생할 수 있으므로 주의해야 합니다.

JPA에서는 기본적으로 지연로딩이 설정되어 있으며, 즉시로딩으로 변경하려면 @ManyToOne이나 @OneToOne 관계에 fetch 속성을 FetchType.EAGER로 지정하면 됩니다. 그리고 지연로딩으로 설정하려면 FetchType.LAZY로 지정하거나 별도의 지연로딩 설정을 할 수 있습니다.


-------------------- 07.20 JPA에서 작업 시 Transactional 단위 진행-----------------------------------

JPA(Java Persistence API)에서의 트랜잭션은 데이터베이스 작업을 하나의 논리적 단위로 묶어서 실행하는 것을 의미합니다.
허가받지 않은 사용자로부터 데이털르 보장하기 위해 DBMS가 가져야 하는 특성입니다.
트랜잭션은 "ACID"라고 불리는 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)이라는 특성을 보장합니다. 이러한 특성을 통해 데이터베이스의 데이터를 안전하게 관리할 수 있습니다.

JPA에서의 트랜잭션은 일반적으로 아래의 순서로 처리됩니다:

트랜잭션 시작 (Begin Transaction): EntityManager를 이용하여 트랜잭션을 시작합니다.
데이터베이스 작업 수행: JPA를 이용하여 데이터베이스 작업(저장, 수정, 삭제, 조회 등)을 수행합니다.
트랜잭션 커밋 (Commit Transaction): 트랜잭션이 성공적으로 수행되면, 데이터베이스에 작업한 내용을 영구적으로 반영합니다.
트랜잭션 롤백 (Rollback Transaction): 만약 트랜잭션 도중에 오류가 발생하면, 트랜잭션을 롤백하여 이전 상태로 되돌립니다.
JPA에서 트랜잭션은 주로 다음과 같은 방법으로 제어됩니다:

@Transactional 어노테이션: Spring Framework를 사용하는 경우, @Transactional 어노테이션을 사용하여 메서드에 트랜잭션을 적용할 수 있습니다.
이 어노테이션이 붙은 메서드는 트랜잭션 경계를 설정하고, 메서드 내부의 데이터베이스 작업은 하나의 트랜잭션으로 묶여 실행됩니다.

@Transactional 어노테이션을 사용하면 직접 EntityManager를 사용하지 않아도 됩니다.
Spring Framework에서 제공하는 @Transactional 어노테이션을 이용하면 트랜잭션을 자동으로 관리해주기 때문에 개발자가 직접 트랜잭션을 시작하고 커밋 또는 롤백할 필요가 없습니다.

@Transactional 어노테이션을 메서드에 추가하면, 해당 메서드의 실행은 하나의 트랜잭션으로 묶이게 됩니다.
메서드가 성공적으로 수행되면 트랜잭션은 커밋되고, 메서드 수행 중에 예외가 발생하면 트랜잭션은 롤백됩니다. 이렇게 @Transactional 어노테이션을 사용하면 트랜잭션의 경계 설정과 예외 처리를 자동으로 처리해줍니다.

예를 들어, 다음과 같이 @Transactional 어노테이션을 사용하여 메서드를 선언하면, 해당 메서드는 트랜잭션을 갖는다고 설정됩니다.

@Service
public class MyService {

    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void saveData(Data data) {
        // 데이터를 저장하는 작업
        myRepository.save(data);
    }

    // 다른 메서드들
    // ...
}

위의 예제에서 saveData() 메서드는 @Transactional 어노테이션을 가지고 있으므로, 해당 메서드를 호출할 때 자동으로 트랜잭션이 시작되고,
메서드 수행이 완료되면 트랜잭션은 커밋됩니다. 만약 메서드 수행 중에 예외가 발생하면 트랜잭션은 롤백됩니다.