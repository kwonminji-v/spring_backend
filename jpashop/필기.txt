
------------------- 07.19 @Entity 어노테이션  ------------------------------

@Entity 어노테이션은 JPA(Java Persistence API)에서 엔티티 클래스를 나타내는 데 사용되는 어노테이션입니다.
엔티티 클래스는 데이터베이스와 매핑되는 객체를 의미하며, JPA를 사용하여 데이터베이스와 상호작용하는데 필요한 정보를 제공합니다.
@Entity 어노테이션을 클래스에 붙이면 해당 클래스가 JPA 엔티티임을 나타냅니다.
JPA는 @Entity 어노테이션이 붙은 클래스를 데이터베이스의 테이블과 매핑하여 객체를 영구 저장소에 저장하고 관리합니다.
@Entity 어노테이션의 주요 특징은 다음과 같습니다:

JPA에서 관리하는 엔티티 클래스는 반드시 @Entity 어노테이션이 붙어야 합니다.
@Entity 어노테이션이 붙은 클래스는 JPA의 영속성 컨텍스트에서 관리되며, 데이터베이스와 매핑되는 역할을 수행합니다.
@Entity 어노테이션을 사용하는 클래스는 기본 생성자가 반드시 필요하며, 파라미터가 없는 기본 생성자를 갖고 있어야 합니다.
@Entity 어노테이션을 사용하여 JPA 엔티티 클래스를 정의하면, JPA는 해당 클래스와 연결된 데이터베이스 테이블을 자동으로 생성하고,
엔티티의 상태를 추적하고, 영속성 컨텍스트를 통해 엔티티를 관리하는 등의 기능을 제공합니다.


------------------- 07.19 @NoArgsConstructor & @AllArgsConstructor------------------------------


@NoArgsConstructor와 @AllArgsConstructor은 Lombok 라이브러리에서 제공하는 어노테이션으로,
자바 클래스의 생성자를 자동으로 생성해주는 기능을 제공합니다. 이를 통해 코드 작성량을 줄이고, 생성자를 간편하게 생성할 수 있습니다.

1. @NoArgsConstructor: 이 어노테이션은 매개변수 없는 디폴트 생성자(Default Constructor)를 자동으로 생성합니다.

import lombok.NoArgsConstructor;

@NoArgsConstructor
public class MyClass {
    // 필드와 메서드들을 정의할 수 있음
}

위의 클래스는 Lombok의 @NoArgsConstructor 어노테이션으로 인해 다음과 같은 디폴트 생성자가 자동으로 생성됩니다:


2. @AllArgsConstructor: 이 어노테이션은 모든 필드를 매개변수로 갖는 생성자를 자동으로 생성합니다.

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class MyClass {
    private String name;
    private int age;
}

위의 클래스는 Lombok의 @AllArgsConstructor 어노테이션으로 인해 다음과 같은 생성자가 자동으로 생성됩니다

public MyClass(String name, int age) {
    this.name = name;
    this.age = age;
}

이처럼 Lombok의 @NoArgsConstructor와 @AllArgsConstructor 어노테이션은 생성자 작성을 간편하게 도와주며, 많은 매개변수를 가지는 생성자를 사용해야할 때
코드의 가독성을 높여줍니다. 그러나 필드의 개수가 많아질수록 생성자의 매개변수도 많아질 수 있으므로, 적절히 사용하는 것이 중요합니다.

이 두 어노테이션을 사용하려면 먼저 Lombok 라이브러리를 프로젝트에 추가해야 합니다. Lombok은 자동으로
getter, setter, equals, hashCode 등의 메서드를 생성하는 등 여러 기능을 제공합니다.
따라서 더 간편한 코드 작성을 위해 Lombok을 활용하는 것이 유용할 수 있습니다.

------------------- 07.19 @Embeddable & @Embedded ------------------------------

@Embeddable과 @Embedded는 스프링 부트에서 JPA를 사용할 때 엔티티 클래스의 속성을 재사용하거나 복합적인 값으로 표현하기 위해 사용되는 어노테이션입니다.

@Embeddable : @Embeddable 어노테이션은 복합적인 값(Composite Value)을 표현하기 위해 사용되는 클래스에 지정됩니다.
즉, 해당 클래스가 다른 엔티티에 속성으로 포함되어 사용될 수 있음을 나타냅니다.
예를 들어, 주소 정보를 여러 엔티티에서 공통으로 사용해야 할 경우 @Embeddable 어노테이션을 사용하여 Address 클래스를 정의하고,
해당 엔티티들의 속성으로 Address 클래스를 사용할 수 있습니다.

@Embeddable
public class Address {
    private String city;
    private String street;
    private String zipCode;

    // getters, setters, constructors, etc.
}

@Embedded : @Embedded 어노테이션은 @Embeddable 어노테이션이 지정된 클래스를 해당 엔티티의 속성으로 포함시킬 때 사용됩니다.
엔티티 클래스의 속성으로 @Embedded 어노테이션을 사용하여 @Embeddable 어노테이션이 지정된 클래스를 포함시킵니다.

@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @Embedded
    private Address address;

    // getters, setters, constructors, etc.
}
위의 예시에서 Customer 엔티티는 Address 클래스를 속성으로 포함하고 있으며, 이렇게 함으로써 Customer 엔티티의 데이터베이스 테이블에 city, street, zipCode 속성들이
컬럼으로 포함됩니다. 이러한 방식으로 코드의 재사용성을 높이고, 복합적인 값들을 관리하기 쉽게 할 수 있습니다.


-------------------- 07.19 Entity 클래스들간의 관계를 나타낼 때 사용되는 어노테이션 -----------------------------------

@OneToOne: 일대일(One-to-One) 관계를 표현할 때 사용됩니다. 두 개의 엔티티 클래스가 서로 하나의 관계를 맺는 경우에 사용합니다.
일대일(OneToOne) 관계: 한 객체가 다른 객체와 하나의 관계만 가지는 것을 의미합니다. 예를 들어, 한 명의 사용자(User)는 하나의 프로필(Profile)을 가진다는 관계가 일대일 관계입니다.

@OneToMany: 일대다(One-to-Many) 관계를 표현할 때 사용됩니다. 하나의 엔티티가 다수의 다른 엔티티와 관계를 맺는 경우에 사용합니다.
일대다(OneToMany) 관계: 한 객체가 다른 객체들과 여러 개의 관계를 가지는 것을 의미합니다. 예를 들어, 한 명의 저자(Author)가 여러 개의 책(Book)을 저술하는 경우 이는 일대다 관계입니다.

@ManyToOne: 다대일(Many-to-One) 관계를 표현할 때 사용됩니다. 다수의 엔티티가 하나의 다른 엔티티와 관계를 맺는 경우에 사용합니다.
다대일(ManyToOne) 관계: 다수의 객체가 하나의 다른 객체와 관계를 가지는 것을 의미합니다. 예를 들어, 여러 개의 주문(Order)이 하나의 사용자(User)와 관련된다면 이는 다대일 관계입니다.

@ManyToMany: 다대다(Many-to-Many) 관계를 표현할 때 사용됩니다. 여러 엔티티가 여러 다른 엔티티들과 서로 다대다 관계를 맺을 때 사용합니다.
다대다(ManyToMany) 관계: 다수의 객체가 다른 다수의 객체들과 관계를 가지는 것을 의미합니다. 예를 들어, 여러 명의 학생(Student)이 여러 개의 과목(Subject)을 수강하는 경우 이는 다대다 관계입니다.

"xToOne의 관계 컬렉션이 아닌 것"이라는 말은 일대다 관계나 다대다 관계를 의미하며, 해당 관계에서는 여러 개의 연결된 객체를 컬렉션으로 가지지 않습니다. 대신, 단일 객체 간의 관계가 형성됩니다.

mappedBy는 JPA에서 양방향(두 엔티티 간에 서로 참조하는) 관계를 매핑할 때 사용되는 속성입니다.
mappedBy는 일반적으로 @OneToMany와 @OneToOne 어노테이션에서 사용됩니다.
양방향 관계를 설정할 때, 일반적으로 한 쪽의 엔티티(주인 엔티티)가 다른 쪽의 엔티티(역방향 엔티티)를 참조하도록 매핑을 지정합니다.
이 때 mappedBy를 사용하여 역방향 엔티티가 어떤 필드를 통해 주인 엔티티와 매핑되었는지를 지정합니다.

예를 들어, 다음과 같이 Post 엔티티와 Comment 엔티티가 있을 때, Post 엔티티가 Comment 엔티티를 일대다 관계로 참조하고 있습니다.

@Entity
public class Post {
    @Id
    @GeneratedValue
    private Long id;

    private String title;

    @OneToMany(mappedBy = "post")
    private List<Comment> comments;

    // Getters, setters, constructors, etc.
}

@Entity
public class Comment {
    @Id
    @GeneratedValue
    private Long id;

    private String text;

    @ManyToOne
    private Post post;

    // Getters, setters, constructors, etc.
}

위의 예시에서 Post 엔티티에서 comments 필드에 @OneToMany(mappedBy = "post") 어노테이션을 사용했습니다.
이렇게 함으로써 Comment 엔티티의 post 필드가 Post 엔티티의 comments 필드를 참조하도록 매핑되었다고 지정합니다. 따라서 양방향으로 관계를 설정할 수 있습니다.

mappedBy는 엔티티 관계에서 중요한 개념이며, 엔티티 간의 관계를 정확하게 설정하기 위해 잘 이해하고 사용하는 것이 중요합니다.

이러한 어노테이션들을 사용하여 엔티티 클래스들 간의 관계를 설정하고, 데이터베이스에서 이를 올바르게 매핑할 수 있습니다.


-------------------- 07.19 Entity간의 연관관계를 가져오는 방식 -----------------------------------

연관 관계의 즉시로딩(Eager Loading)과 지연로딩(Lazy Loading)은 JPA에서 엔티티 간의 관계를 가져오는 방식을 나타내는 개념입니다.

즉시로딩 (Eager Loading):
즉시로딩은 엔티티를 조회할 때, 해당 엔티티와 연관된 다른 엔티티들을 모두 한 번에 가져오는 방식입니다. 예를 들어, 엔티티 A와 B가 일대다(One-to-Many) 관계를 가지고 있을 때, 
A를 조회할 때 연관된 모든 B 엔티티들도 함께 조회하는 방식이 즉시로딩입니다. 이렇게하면 한 번의 쿼리로 모든 연관 엔티티를 가져올 수 있지만, 데이터베이스의 부담이 커질 수 있습니다.
즉시로딩의 장점은 조회한 엔티티와 연관된 데이터들을 사용할 때 데이터베이스 조회가 필요없이 바로 접근할 수 있어서 성능이 좋을 수 있습니다.
 그러나 연관된 데이터가 많고 복잡할 경우에는 성능 이슈가 발생할 수 있으므로 신중하게 사용해야 합니다.

지연로딩 (Lazy Loading):
지연로딩은 연관된 엔티티를 실제로 사용하는 시점까지 데이터베이스에서 가져오지 않고, 해당 엔티티가 실제로 필요할 때 가져오는 방식입니다.
즉, 해당 연관 엔티티를 사용하는 순간에 데이터베이스에서 조회하여 가져오게 됩니다.
지연로딩은 실제로 해당 데이터가 사용되지 않는 경우에는 데이터베이스 조회를 하지 않으므로, 성능상의 이점이 있습니다.
지연로딩의 장점은 원하는 시점에 실제로 필요한 데이터만 가져오기 때문에 데이터베이스 부하를 줄일 수 있습니다. 그러나 지연로딩된 엔티티를 사용하는 시점에
영속성 컨텍스트의 범위를 벗어난 경우에는 LazyInitializationException 예외가 발생할 수 있으므로 주의해야 합니다.

JPA에서는 기본적으로 지연로딩이 설정되어 있으며, 즉시로딩으로 변경하려면 @ManyToOne이나 @OneToOne 관계에 fetch 속성을 FetchType.EAGER로 지정하면 됩니다.
그리고 지연로딩으로 설정하려면 FetchType.LAZY로 지정하거나 별도의 지연로딩 설정을 할 수 있습니다.


-------------------- 07.20 JPA에서 작업 시 Transactional 단위 진행-----------------------------------

JPA(Java Persistence API)에서의 트랜잭션은 데이터베이스 작업을 하나의 논리적 단위로 묶어서 실행하는 것을 의미합니다.
허가받지 않은 사용자로부터 데이털르 보장하기 위해 DBMS가 가져야 하는 특성입니다.
트랜잭션은 "ACID"라고 불리는 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)이라는 특성을 보장합니다.
이러한 특성을 통해 데이터베이스의 데이터를 안전하게 관리할 수 있습니다.

JPA에서의 트랜잭션은 일반적으로 아래의 순서로 처리됩니다:

트랜잭션 시작 (Begin Transaction): EntityManager를 이용하여 트랜잭션을 시작합니다.
데이터베이스 작업 수행: JPA를 이용하여 데이터베이스 작업(저장, 수정, 삭제, 조회 등)을 수행합니다.
트랜잭션 커밋 (Commit Transaction): 트랜잭션이 성공적으로 수행되면, 데이터베이스에 작업한 내용을 영구적으로 반영합니다.
트랜잭션 롤백 (Rollback Transaction): 만약 트랜잭션 도중에 오류가 발생하면, 트랜잭션을 롤백하여 이전 상태로 되돌립니다.
JPA에서 트랜잭션은 주로 다음과 같은 방법으로 제어됩니다:

@Transactional 어노테이션: Spring Framework를 사용하는 경우, @Transactional 어노테이션을 사용하여 메서드에 트랜잭션을 적용할 수 있습니다.
이 어노테이션이 붙은 메서드는 트랜잭션 경계를 설정하고, 메서드 내부의 데이터베이스 작업은 하나의 트랜잭션으로 묶여 실행됩니다.

@Transactional 어노테이션을 사용하면 직접 EntityManager를 사용하지 않아도 됩니다.
Spring Framework에서 제공하는 @Transactional 어노테이션을 이용하면 트랜잭션을 자동으로 관리해주기 때문에 개발자가 직접 트랜잭션을 시작하고 커밋 또는 롤백할 필요가 없습니다.

@Transactional 어노테이션을 메서드에 추가하면, 해당 메서드의 실행은 하나의 트랜잭션으로 묶이게 됩니다.
메서드가 성공적으로 수행되면 트랜잭션은 커밋되고, 메서드 수행 중에 예외가 발생하면 트랜잭션은 롤백됩니다. 이렇게 @Transactional 어노테이션을 사용하면 트랜잭션의 경계 설정과 예외 처리를 자동으로 처리해줍니다.

예를 들어, 다음과 같이 @Transactional 어노테이션을 사용하여 메서드를 선언하면, 해당 메서드는 트랜잭션을 갖는다고 설정됩니다.

@Service
public class MyService {

    @Autowired
    private MyRepository myRepository;

    @Transactional
    public void saveData(Data data) {
        // 데이터를 저장하는 작업
        myRepository.save(data);
    }

    // 다른 메서드들
    // ...
}

위의 예제에서 saveData() 메서드는 @Transactional 어노테이션을 가지고 있으므로, 해당 메서드를 호출할 때 자동으로 트랜잭션이 시작되고,
메서드 수행이 완료되면 트랜잭션은 커밋됩니다. 만약 메서드 수행 중에 예외가 발생하면 트랜잭션은 롤백됩니다.


Spring 프레임워크에서 데이터베이스와 관련된 작업을 처리할 때 커밋(Commit)과 롤백(Rollback)은 중요한 개념입니다.
이들은 데이터베이스 트랜잭션(Transaction)의 일부로서, 여러 데이터베이스 작업들을 논리적인 단위로 묶고, 작업의 원자성, 일관성, 격리성, 지속성(ACID)을 보장합니다.
Spring은 트랜잭션 관리를 지원하기 위해 여러 방법을 제공합니다.

커밋 (Commit):

커밋은 트랜잭션의 성공적인 완료를 의미합니다.
데이터베이스에 수행한 모든 변경 사항이 영구적으로 저장되고, 트랜잭션은 종료됩니다.
트랜잭션 내의 모든 작업들이 정상적으로 처리되었을 때 커밋을 수행합니다.
커밋을 호출하면 트랜잭션의 변경 내용이 영구적으로 반영되며, 이후의 변경 사항은 롤백으로 취소할 수 없습니다.

롤백 (Rollback):

롤백은 트랜잭션의 실패 또는 명시적인 취소를 의미합니다.
트랜잭션 내의 작업 중 하나라도 실패하거나, 예외가 발생하면 해당 트랜잭션은 롤백됩니다.
롤백을 호출하면 트랜잭션 내의 모든 변경 사항이 취소되고, 데이터베이스는 이전 상태로 돌아갑니다.

------------------------ 07-21   @RequiredArgsConstructor 어노테이션 (상품도메인) -----------------------------------------
@RequiredArgsConstructor는 Lombok 라이브러리에서 제공하는 애노테이션으로, 주로 생성자를 자동으로 생성해주는 기능을 제공합니다.

주로 사용하는 경우는 다음과 같습니다:

final 키워드가 붙은 필드를 가진 클래스: @RequiredArgsConstructor를 사용하면 해당 클래스의 final 키워드가
붙은 필드를 생성자의 매개변수로 받는 생성자가 자동으로 생성됩니다.

@NonNull 애노테이션이 적용된 필드: @NonNull 애노테이션이 적용된 필드는 생성자에서 널(null) 값을 허용하지 않도록 만듭니다.
따라서 @RequiredArgsConstructor를 사용하면 널 값이 아닌 필드를 가진 생성자가 자동으로 생성됩니다.

------------------------ 07-22 영속화(persist) (상품도메인) --------------------------------------
영속화(persist)는 JPA에서 엔티티 객체를 영구 저장소(데이터베이스)에 저장하는 과정을 의미합니다.
JPA에서 영속성 컨텍스트(Persistence Context)라는 개념을 사용하여 엔티티 객체의 상태를 관리하며, 영속성 컨텍스트에 포함된 엔티티 객체는 데이터베이스에 반영됩니다.

영속화는 일반적으로 다음과 같은 방법으로 수행됩니다:

새로운 엔티티 객체를 생성합니다.
엔티티 매니저(EntityManager)를 사용하여 엔티티 객체를 영속성 컨텍스트에 등록합니다. 이때, persist() 메서드를 호출하여 영속화를 수행합니다.
영속성 컨텍스트는 엔티티 객체의 상태를 감시하며, 변경된 엔티티를 데이터베이스에 저장하기 위해 적절한 시점에 SQL 쿼리를 생성하여 실행합니다.
데이터베이스에 엔티티 객체의 상태가 반영되고, 해당 엔티티 객체는 영속 상태가 됩니다.
영속화를 통해 엔티티 객체는 영속성 컨텍스트에 의해 관리되기 때문에, 영속 상태인 엔티티는 변경이 감지되면 자동으로 데이터베이스에 반영됩니다.
또한, 영속 상태의 엔티티는 캐싱되어서 동일한 엔티티에 대한 여러 조회 작업에 대한 성능을 향상시킬 수 있습니다.

반대로 영속 상태의 엔티티를 영속성 컨텍스트에서 분리하거나, 데이터베이스에서 삭제하려면 detach() 또는 remove() 메서드를 사용하여 분리하거나 삭제할 수 있습니다.

주문 상품 엔티티와 일 대 다 매핑을 합니다.
1. 외래키(order_id)가 ordre_item테이블에 있으므로 연관 관계의 주인은 OrderItem 엔티티입니다. Order 엔티티가 주인이 아니므로 "mappedBy" 속성으로 연관 관계의 주인을 설정합니다.
속성의 값으로 "order"를 적어준 이유는 OrderItem에 있는 Order에 의해 관리된다는 의미로 해석하시면 됩니다.
즉, 연관관계의 주인의 필드인 order를 mappedBy의 값으로 세팅하면 됩니다.


영속성 전이 즉, 'cascade'의 사전적 정의는 '작은 폭포', '폭포처럼 흐르다' 라는 뜻입니다.
영속성 전이란 엔티티의 상태를 변경할 대 해당 엔티티와 연관된 엔티티의 상태변화를 전파시키는 옵션입니다.
이 때, 부모는 One에 해당하고 자식은 Many에 해당합니다.
예를 들어, Order 엔티티에 담겨있는 OrderItem 엔티티를 한꺼번에 저장할 수 있습니다.
상태가 전파되는 모습을 폭포가 흐르는 모습으로 상상하면 떠올리기 쉽기 때문에 폭포처럼 흐르다의 뜻을 사용합니다.
PERSIST : 부모 엔티티가 영속화 될 때 자식 엔티티도 영속화
ALL : 부모 엔티티의 영속성 상태 변화를 자식 엔티티에 모두 전이

고아 객체는 어떤 부모 엔티티에서 더 이상 참조되지 않는 자식 엔티티를 말합니다.
고아 객체를 자동으로 DB에서 삭제하는 '고아 객체 제거 (OrphanRemoval)' 기능을 제공합니다.
orphanRemoval=true로 설정하여 주문에서 주문 항목을 제거하면 동시에 DB에서도 그 주문 항목이 삭제되도록 할 수 있습니다.

------------------------ 07-24 em.persist(상품도메인) --------------------------------------

em.persist()는 JPA(Entity Manager)에서 엔티티를 영속성 컨텍스트에 저장(추가)하는 메서드입니다. JPA에서 영속성 컨텍스트는 엔티티의 생명주기를 관리하며,
em.persist()를 사용하여 엔티티를 영속성 컨텍스트에 추가하면 해당 엔티티가 데이터베이스에 반영될 수 있도록 준비됩니다.

em.persist() 메서드를 사용하는 방법은 다음과 같습니다:

엔티티 클래스 정의: 먼저 JPA에서 관리하고자 하는 엔티티 클래스를 정의합니다. 엔티티 클래스는 @Entity 어노테이션으로 표시되어야 합니다.

@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    // Getter, Setter, 기타 메서드들
    // ...
}

엔티티 매니저 주입: em.persist()를 사용하려면 EntityManager를 주입받아야 합니다. 스프링 기반 애플리케이션에서는
@Autowired 등을 사용하여 EntityManager를 주입받을 수 있습니다.

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

@Service
public class MemberService {

    @PersistenceContext
    private EntityManager em;

    // 이후 엔티티 매니저를 사용하는 서비스 로직 작성
    // ...
}
엔티티 저장: em.persist()를 사용하여 엔티티를 영속성 컨텍스트에 저장(추가)합니다.

@Service
public class MemberService {
    @PersistenceContext
    private EntityManager em;

    public void saveMember(Member member) {
        em.persist(member); // 엔티티를 영속성 컨텍스트에 추가
    }
}
위의 saveMember() 메서드에서 em.persist(member)를 호출하면 member 엔티티가 영속성 컨텍스트에 추가됩니다.
이후 @Transactional 어노테이션과 같이 사용하여 트랜잭션 범위에서 커밋되면, 영속성 컨텍스트에 있는 엔티티가 데이터베이스에 반영되게 됩니다.

참고로, em.persist()를 호출한 후에 바로 데이터베이스에 저장되지 않습니다. JPA에서는 트랜잭션을 커밋하는 시점에 영속성 컨텍스트에 있는 변경 내용을 데이터베이스에 동기화합니다.
따라서 em.persist()를 호출하더라도 해당 엔티티는 데이터베이스에 반영되지 않을 수 있습니다. 영속성 컨텍스트와 트랜잭션의 동작 방식을 이해하는 것이 중요합니다.

-------------------------- 08-01 @Transactional  --------------------------------------

@Transactional 어노테이션은 메서드 또는 클래스에 적용하여 해당 메서드 또는 클래스의 모든 메서드를 하나의 트랜잭션으로 묶어주는 역할을 합니다.
트랜잭션은 여러 개의 데이터베이스 작업을 하나의 논리적 작업으로 처리하는 것을 의미합니다. 트랜잭션은 모든 작업이 성공적으로 수행되면 커밋(Commit)되어
변경사항이 영구적으로 적용되고, 하나라도 실패하면 롤백(Rollback)되어 모든 변경사항이 취소됩니다..


    @Transactional
    public void update(Long id, String name) {

        Member member = memberRepository.findOne(id);
        member.setName(name);
    }

update 메서드는 id와 name이라는 두 개의 파라미터를 받습니다.
memberRepository.findOne(id)를 통해 데이터베이스에서 주어진 id에 해당하는 Member 객체를 조회합니다. 조회된 Member 객체의 name을 파라미터로 받은 name으로 변경합니다.

위의 기능을 트랜잭션으로 관리하는 이유는 다음과 같습니다:

트랜잭션을 사용하지 않으면 각각의 데이터베이스 작업이 별개의 단위로 처리되기 때문에 하나의 작업이 실패해도
다른 작업은 영향을 받지 않고 실행될 수 있습니다. 예를 들어, findOne 메서드에서 데이터를 조회하고 setName 메서드에서
이름을 변경하는 도중에 예외가 발생하면 조회한 데이터가 변경되지 않아야 합니다.

트랜잭션을 사용하면 모든 데이터베이스 작업은 하나의 논리적인 단위로 처리되므로, 하나의 작업이 실패하면 모든 작업이 롤백되어 이전 상태로 복구됩니다.
따라서 @Transactional 어노테이션을 사용하여 update 메서드는 하나의 트랜잭션으로 묶여 있으며, 모든 데이터베이스 작업은 원자적(Atomic)으로 처리됩니다.
원자성은 모든 작업이 성공적으로 완료되거나 전혀 수행되지 않는 것을 보장합니다.

1. @Transactional 어노테이션으로 인해 update 메서드는 하나의 트랜잭션 내에서 실행됩니다. 즉, 트랜잭션이 시작되고 메서드가 종료될 때까지 해당 트랜잭션은 활성화된 상태입니다.

2. memberRepository.findOne(id)는 주어진 id를 사용하여 데이터베이스에서 Member 엔티티를 조회합니다. 이 조회는 영속성 컨텍스트를 통해 이루어집니다.

3.조회한 Member 엔티티는 영속성 컨텍스트에서 관리되는 영속 상태의 엔티티가 됩니다. 따라서 이후 해당 Member 엔티티의 필드들을 변경하더라도,
트랜잭션이 커밋되기 전까지는 데이터베이스에는 변경사항이 반영되지 않습니다.

4. member.setName(name)은 조회한 Member 엔티티의 이름을 주어진 name으로 변경합니다. 이 변경은 영속성 컨텍스트에서만 일어나며, 데이터베이스에는 아직 반영되지 않습니다.

5. @Transactional 어노테이션으로 인해 메서드가 종료되면 트랜잭션은 커밋됩니다. 커밋되면 영속성 컨텍스트는 변경사항을
데이터베이스에 반영하여 영속 상태의 Member 엔티티가 영구 저장소에 저장되도록 합니다.

6. 만약 트랜잭션 도중 예외가 발생한다면, 트랜잭션은 롤백되어 변경사항이 모두 취소됩니다. 데이터베이스는 변경되지 않은 상태로 유지됩니다.

------------------------- 08-01 영속성 컨텍스트 ----------------------------------------

JPA는 데이터베이스와 자바 객체를 매핑하여 객체를 데이터베이스에 저장하고 조회하는 기술입니다.
JPA에서 관리되는 엔티티는 영속성 컨텍스트(Persistence Context)에 의해 관리됩니다.
영속성 컨텍스트는 논리적인 영역으로, JPA가 엔티티를 데이터베이스와 매핑하고 변경사항을 추적하며 관리하는 공간입니다.

따라서 memberRepository.findOne(id)에서 JPA는 데이터베이스에서 id에 해당하는 데이터를 조회한 후, 이 데이터를 영속성 컨텍스트에 저장합니다.
이로 인해 조회한 엔티티는 영속 상태(Persistent State)가 됩니다. 즉, 영속성 컨텍스트에 의해 관리되는 엔티티로서,
이후 변경사항을 추적하고, 트랜잭션이 커밋되는 시점에 데이터베이스에 반영되도록 준비가 됩니다.

영속성 컨텍스트에 의해 관리되는 엔티티는 세 가지 상태를 가질 수 있습니다:

1. Transient State (비영속 상태): 새로 생성된 객체로, JPA가 아직 관리하지 않는 상태입니다.

2. Persistent State (영속 상태): 영속성 컨텍스트에 의해 관리되는 상태로, 데이터베이스에 저장된 엔티티이며 변경사항을 추적하고 관리합니다.

3. Detached State (준영속 상태): 영속성 컨텍스트와의 연결이 끊긴 상태로, 영속성 컨텍스트에서 분리된 엔티티입니다. 이후 다시 연결하여 사용할 수도 있습니다.

따라서 JPA에서는 조회된 엔티티가 영속성 컨텍스트에 저장되어 영속 상태가 되는 것이 일반적인 동작입니다. 이로 인해 조회된 엔티티는 이후 변경사항을
영속성 컨텍스트에 의해 추적하여 데이터베이스에 반영될 수 있게 됩니다. 이러한 동작은 영속성 컨텍스트의 장점 중 하나로, 엔티티를 관리하는데 편리함을 제공합니다.

------------------------- 08-01 JPA 기본 개념 ----------------------------------------

JPA(Java Persistence API)는 객체와 데이터베이스 간의 매핑을 담당하는 기술로서, 개발자가 직접 SQL 쿼리문을 작성하지 않고도 데이터베이스와
상호작용할 수 있게 해줍니다. JPA는 객체 지향적인 접근 방식을 사용하여 데이터베이스와 통신하고, SQL 쿼리문을 자동으로 생성해 줍니다.

이를 가능하게 하는 주요 원리는 다음과 같습니다:

1. 객체와 테이블 간의 매핑: JPA는 엔티티(Entity) 클래스를 데이터베이스의 테이블과 매핑합니다. 즉, 엔티티 클래스의 필드들은 테이블의 컬럼과 매핑되며,
객체 간의 관계는 데이터베이스의 관계로 매핑됩니다.

2. JPQL (Java Persistence Query Language): JPA는 객체 지향 쿼리 언어인 JPQL을 제공합니다. JPQL은 SQL과 유사한 형태로 작성되지만,
테이블이 아닌 엔티티와 관계를 중심으로 쿼리를 작성합니다. JPQL은 데이터베이스에 독립적이므로, 특정 데이터베이스 종속적인 SQL 쿼리문을 작성하지 않아도 됩니다.

3. Criteria API: JPA는 Criteria API를 제공하여 JPQL과 유사한 방식으로 쿼리를 작성할 수 있게 합니다.
Criteria API는 JPQL을 문자열로 작성하는 대신, 자바 코드로 쿼리를 작성할 수 있도록 도와줍니다.

4. Flush and Commit: JPA에서는 영속성 컨텍스트에 변경사항이 모여 트랜잭션이 커밋되는 시점에 적절한 SQL 쿼리문이 데이터베이스에 자동으로 생성됩니다.
이러한 작업을 플러시(Flush)라고 하며, 변경사항을 데이터베이스에 반영하는 것을 커밋(Commit)이라고 합니다.

5. Lazy Loading과 Eager Loading: JPA는 객체 간의 연관 관계를 지연 로딩(Lazy Loading) 또는 즉시 로딩(Eager Loading)으로 설정할 수 있습니다.
이에 따라 필요한 데이터만 조회하여 쿼리를 최적화하는 기능을 제공합니다.

위의 원리들을 기반으로 JPA는 개발자가 객체 지향적인 코드를 작성하면, JPA가 적절한 SQL 쿼리문을 자동으로 생성하여 데이터베이스와 통신합니다.
이를 통해 데이터베이스와 상호작용하는 과정을 추상화하고, 개발자는 객체를 중심으로 코드를 작성하며 데이터베이스와의 상세한 상호작용은 JPA가 처리하도록 합니다.
이러한 방식으로 개발자가 데이터베이스와 직접적으로 상호작용하는 부분을 최소화하고, 생산성과 유지보수성을 높일 수 있습니다.

------------------------- 08-01 @Restfull ----------------------------------------

@RestController 어노테이션은 Spring Framework에서 제공하는 컨트롤러(Controller)를 정의하는데 사용되는 어노테이션 중 하나입니다.
@RestController 어노테이션은 @Controller 어노테이션과 @ResponseBody 어노테이션을 합친 것과 같은 역할을 합니다.

간단히 말하면, @RestController 어노테이션을 사용하면 해당 컨트롤러의 메서드들이 자동으로 JSON, XML 등의 응답을 만들어 클라이언트에게 반환하도록 설정할 수 있습니다.

일반적인 @Controller 어노테이션을 사용한 컨트롤러에서는 메서드의 반환 타입이 String으로 지정되면, 해당 메서드가 반환하는 문자열은 뷰(View)의
이름으로 인식됩니다. 그러면 이 뷰 이름에 해당하는 뷰 페이지를 찾아 렌더링하여 클라이언트에게 응답합니다.
이렇게 뷰를 템플릿 엔진을 사용하여 렌더링하는 방식은 주로 서버 사이드 렌더링(Server-side Rendering) 방식으로 사용됩니다.

반면, @RestController 어노테이션을 사용한 컨트롤러에서는 메서드의 반환 타입이 String인 경우 뷰 페이지를 찾아가는 것이 아니라,
그 문자열 자체가 클라이언트에게 바로 반환됩니다. 이 때, 자바 객체를 반환하면 해당 객체가 자동으로 JSON이나 XML 형태로 변환되어 클라이언트에게 전달됩니다.
 이 방식은 RESTful API를 구현하는데 주로 사용되며, 클라이언트와 서버 간에 JSON이나 XML과 같은 데이터를 주고받을 때 편리합니다.

즉, @RestController 어노테이션은 컨트롤러 클래스의 모든 메서드에 @ResponseBody 어노테이션을 자동으로 적용하여 해당 메서드들이
JSON, XML 등의 데이터 형식으로 응답을 만들어주는 역할을 합니다. 이를 통해 클라이언트와의 데이터 교환을 쉽게 처리할 수 있습니다.


------------------------- 08-02 Fetch Join ----------------------------------------

패치 조인(Fetch Join)은 데이터베이스에서 연관된 엔티티들을 함께 조회하는 JPA의 기능입니다.
일반적으로 엔티티들간에 연관 관계가 있을 때, 지연 로딩(Lazy Loading)이 기본 설정인 경우, 해당 연관된 엔티티들은 실제로 사용될 때까지 데이터베이스에서 가져오지 않습니다.
그래서 사용할 때마다 추가적인 쿼리가 실행되며, 성능 이슈가 발생할 수 있습니다.

패치 조인은 이러한 지연 로딩의 문제를 해결하기 위해 사용됩니다. 패치 조인을 사용하면 연관된 엔티티들을 한 번에 함께 조회하므로
추가적인 쿼리를 발생시키지 않고, 데이터베이스의 부담을 줄여 성능을 개선할 수 있습니다.

패치 조인은 JPA의 JOIN FETCH 구문을 사용하여 사용할 수 있습니다. 보통 JPQL(Querydsl에서도 사용 가능)이나 Criteria API에서 패치 조인을 사용합니다.

예를 들어, 다음은 패치 조인을 사용한 JPQL 쿼리의 예입니다:

SELECT o FROM Order o JOIN FETCH o.items

위 쿼리는 Order 엔티티와 Order와 연관된 Item 엔티티들을 함께 조회하는 패치 조인을 수행합니다.
이렇게 함께 조회된 Item 엔티티들은 지연 로딩이 아닌 즉시 로딩되어 영속성 컨텍스트에 캐시되며, 추가적인 쿼리를 실행하지 않고도 관련된 데이터를 사용할 수 있습니다.

패치 조인은 항상 적절한 경우에 사용해야 하며, 연관된 엔티티가 많은 경우에는 데이터베이스 성능에 영향을 줄 수 있으므로 주의가 필요합니다.
사용 시에는 필요한 데이터만 패치 조인하고, 불필요한 데이터는 지연 로딩으로 처리하는 것이 좋습니다.